### 多线程编程！其乐无穷！！！
来看看下面一段代码
小明的小小线程池库中实现的join功能如下，小明不想在整个作用域加锁，这样可能会导致池中其他正在正常工作的线程被阻塞。他采用了一个分段加锁的方法。但这其中隐藏着一个竞态条件(Race condition)聪明的你能找到他吗？
``` C
uint32_t ThreadPool::pool_id_join(uint32_t id){
    if(id >= MAX_thread_N)
        return -1;
    /* 我想在这个函数中尽可能少的加锁，以避免堵塞其他正在正常工作的线程 */
    // std::lock_guard<std::mutex> lock(status_mutex);

    {
    std::lock_guard<std::mutex> lock(status_mutex);
    if(this->thread_status[id] == THP_IDLE)
        return -1;
    }

    if(pool[id].joinable()){
        pool[id].join();
        {
        std::lock_guard<std::mutex> lock(status_mutex);
        thread_status[id] = THP_IDLE;
        return 0;
        }
    }
    return -1;
}

```

